## Batch JSON

Certainly! I'll provide a guide to help understand the sections in the JSON file you provided. The structure primarily contains two main sections: **globals** and **nodes**. Each of these will be explained in detail.

### Sections Overview

1. **Globals**  
   - **Purpose**: A set of global parameters that can be referenced throughout the processing pipeline. They act as placeholders for key input and output settings, such as file paths and reconstruction options.
   - **Adjustments**: Modifying global values allows for changing input/output files and controlling overall behavior. For example:
     - `input_pointcloud`: Change this to the file path of the input point cloud.
     - `output_obj_lod12`: Update this to specify where the LoD 1.2 OBJ output file will be saved.

2. **Nodes**  
   - **Purpose**: This section defines individual tasks within the reconstruction workflow. Each node represents a module that performs a specific operation, such as reading or writing data, converting formats, or simplifying geometry.
   - **Adjustments**: Each node has its own set of parameters and connections. Here are examples of notable nodes:
     - `OGRLoader`: This node loads the input 2D footprint file. Adjust parameters like `filepath` and `layer_name` to change which layer is processed.
     - `CityJSONWriter`: Writes the 3D model to the CityJSON format. Parameters like `filepath` and `identifier_attribute` define output paths and identifiers.
     - `OBJVecWriter-LoD12`, `OBJVecWriter-LoD13`, `OBJVecWriter-LoD22`: Each of these nodes exports the 3D models to different LoD levels. Adjust the `filepath` parameter for each to control where they are written.

### Example Section Breakdown

Let's break down a particular example: the **CityJSONWriter** node.

```json
"CityJSONWriter": {
  "marked_inputs": {
    "attributes": false,
    "footprints": false,
    "geometry_lod12": false,
    "geometry_lod13": false,
    "geometry_lod22": false,
    "part_attributes": false
  },
  "parameters": {
    "CRS": "{{output_crs_wkt}}",
    "filepath": "{{output_cityjson}}",
    "identifier_attribute": "{{building_identifier}}",
    "meta_title": "3D model generated by Geoflow"
  }
}
```

**Explanation**:

- **Inputs** (`marked_inputs`): Identifies what kind of data the node requires to perform its task.
  - `attributes`: Metadata or surface semantics to include in the final CityJSON file.
  - `footprints`: The 2D polygons of the buildings.
- **Parameters**:
  - `CRS`: Specifies the coordinate reference system for the CityJSON file.
  - `filepath`: Where the CityJSON file will be saved. The placeholder here refers to the global variable.
  - `identifier_attribute`: Attribute used to uniquely identify buildings in the CityJSON file.
  - `meta_title`: Metadata added to the output.

**Adjustments**:

- Update `meta_title` to provide custom metadata in the CityJSON file.
- Change `filepath` if you want to save the CityJSON file to a different location.

### Summary

The file primarily defines a flowchart-like processing pipeline by combining different nodes, each with their own role and input/output connections. Globals provide centralized parameters that nodes reference, ensuring that changing a value (e.g., an input file path) updates all connected nodes.

You can modify global parameters to change the behavior of the entire workflow or tweak individual nodes to customize the output format or apply special conditions.

Let me know if you'd like a similar guide for the other JSON file.


## Single JSON

Let's walk through the second JSON file you provided. This will follow a similar structure to the first guide, explaining the globals and nodes and offering suggestions on how you might adjust them to meet your requirements.

### Sections Overview

1. **Globals**
   - **Purpose**: Define global parameters that control the input data, output locations, and various processing settings.
   - **Adjustments**: Changing these parameters will have an impact across the entire workflow. Here are some notable parameters and how to adjust them:
     - `input_footprint`: Change this to specify the path to your 2D building footprints file (e.g., a `.gpkg` or `.shp` file).
     - `input_pointcloud`: Set this to the path of the point cloud data file.
     - `output_obj_lod12`, `output_obj_lod13`, `output_obj_lod22`: Adjust these to change where each level of detail (LoD) model is saved.
     - `output_cityjson`: Set this to where the final CityJSON file should be written.

2. **Nodes**
   - **Purpose**: Nodes represent discrete processing tasks that act as a workflow for handling point cloud data, footprint geometry, and the final 3D model. The data is passed from one node to the next, which perform tasks like reading files, filtering points, writing output files, etc.
   - **Adjustments**: Each node has connections and parameters that influence the processing. Let's review a few notable nodes:
     - `OGRLoader`: Loads the 2D footprint data. Adjust the `filepath` parameter to point to your desired 2D footprint file. Other options include `layer_name` and `attribute_filter` for filtering data.
     - `CityJSONWriter`: Writes the 3D model to CityJSON format. Customize the `filepath`, `identifier_attribute`, and metadata attributes like `meta_title`.
     - `OBJVecWriter-LoD12`, `OBJVecWriter-LoD13`, `OBJVecWriter-LoD22`: Nodes that output OBJ models at different levels of detail (LoD). Modify the `filepath` parameter to set where the output models will be saved.

### Example Section Breakdown

Let's analyze the **PolygonSimplifyGEOS** node.

```json
"PolygonSimplifyGEOS": {
  "connections": {
    "simplified_polygons": [
      ["LASInPolygons", "polygons"],
      ["NestedFlowchart", "LOD1Extruder-LoD11.polygon"],
      ["NestedFlowchart", "AttrRingsSelector-LoD12.linear_rings_A"],
      ["PolygonBufferGEOS", "polygons"]
    ]
  },
  "marked_inputs": {
    "polygons": false
  },
  "marked_outputs": {
    "simplified_polygons": false
  },
  "parameters": {
    "orient_after_simplify": true,
    "output_failures": true,
    "tolerance": 0.009999999776482582
  },
  "position": [153.0, 195.0],
  "type": ["io-gdal", "PolygonSimplifyGEOS"]
}
```

**Explanation**:

- **Inputs/Outputs** (`connections`, `marked_inputs`, `marked_outputs`): The node simplifies polygons provided via the `polygons` input and outputs the processed data as `simplified_polygons`.
- **Parameters**:
  - `orient_after_simplify`: Adjusts whether the orientation of the polygons is corrected post-simplification.
  - `output_failures`: Specifies whether to output polygons that could not be simplified successfully.
  - `tolerance`: Defines the tolerance used for simplification.

**Adjustments**:

- Change the `tolerance` value to control the degree of simplification. A higher value will result in a more generalized (simplified) polygon, while a lower value will produce more detail.

### Summary

This file structures the workflow similarly to the first JSON file. Globals control key inputs/outputs and parameters, while nodes represent modular steps in the processing pipeline. Adjusting global parameters or modifying nodes allows you to customize how data is processed, output, and optimized.

If you'd like additional guidance or further explanation of particular nodes or parameters, I'd be happy to elaborate!

## Differences

The two JSON files describe similar workflows for reconstructing 3D building models from point cloud data, but with differences in their structure, nodes, and global parameters.

### Key Differences

1. **Folder Structure**:  
   - The first file is located in a folder named "batch."
   - The second file is in a folder named "single."

   This distinction suggests that the "batch" workflow might process multiple buildings at once, while the "single" workflow focuses on reconstructing a single building model.

2. **Globals**:
   - In both files, the globals section defines key parameters such as input/output file paths and LoD specifications.
   - The second file ("single") includes additional parameters for metadata, like contact name, email, and reference date. These allow for more detailed customization of the CityJSON output.
   - Some tolerance and reconstruction settings are specified only in the first ("batch") file, allowing for greater control over detailed optimization of building models.

3. **Nodes**:
   - **Nested Flowcharts**:  
     - Both files have nested flowcharts, but the first one includes additional nodes for processing mesh quality, segmentation, and validation.
   - **Output Nodes**:  
     - Both files include `CityJSONWriter` and `OBJVecWriter` nodes for different levels of detail (LoD). However, the `batch` file contains extra nodes like `OGRWriter-LoD11` and `PolygonSimplifyGEOS`.
     - The `batch` workflow includes a `SegmentRasterise` node, which may allow segmentation of ground features or other characteristics that affect reconstruction.
   - **Point Cloud Filtering**:  
     - Both files include nodes for handling point cloud data, but the first file ("batch") includes more nodes related to processing classifications and optimizing mesh quality.

### Usage Implications

- **Batch Workflow** (First JSON):  
  This workflow is designed to handle multiple buildings simultaneously, with nodes for batch operations and segmentation, as well as extra validation and optimization steps. It may be useful for projects that require processing large datasets efficiently.

- **Single Workflow** (Second JSON):  
  This workflow focuses on individual building reconstruction, allowing greater customization and metadata control over the final 3D model. It would be ideal for projects requiring detailed semantic information in the output.

### Conclusion

In summary, the two files are variations of a similar building reconstruction workflow but differ in their intended purpose, level of detail in processing, and global parameters. The batch file has a broader scope and extra validation nodes, while the single file allows for granular customization and processing of a single building model.